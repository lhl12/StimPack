function [data_epoched, epoch_indices] = pullStimEpochs(data, burst_limits, fsData, fsSing, pre, post, adjust)
%PULLSTIMEPOCHS pulls epochs of identical size from provided data based on
%the stimulation and provided limits

%   INPUTS:
%   data: data to be split into epochs (a time x channels array)
%   burst_limits: the start and end indices of each stimulation burst, as
%       generated by getStimIndices() (a trials x 2 array)
%   fsData: the sampling rate of data
%   fsSing: the sampling rate of the Sing TDT output that was used to
%       generate burst_limits
%   pre: the number of seconds to include in epoch prior to burst start
%   post: the number of seconds to include in epoch after burst start (this
%       will include the rest of the burst window to account for potential
%       differences in burst length
%   adjust: a boolean determining if you would like to adjust for
%       differences between TDT stimulation signal and stimulation artifact in
%       the data (defaults to 0)

%   OUTPUTS:
%   data_epoched: the data split into epochs (a time x channels x trials
%       array)
%   epoch_indices: the indices used to pull epochs from the given data,
%       accounting for sampling rate differences and adjustment for lag

%   ASSUMPTIONS:

    %% Adjust for any differences in sampling rate
    
    fsRat = fsData/fsSing;
    dataStarts = round(fsRat*burst_limits(:, 1));
    
    %% Adjust for lag between stimulation onset signal and stimulation artifact
    
    if ~exist('adjust', 'var')
        adjust = false;
    end
    if adjust
        dataDiff = diff(data);
        [~,chanMax] = (max(max(dataDiff)));
        chanMax = chanMax(1);

        diffSig = dataDiff(:, chanMax);
        pklocs = find(abs(zscore(diffSig)) > thresh);
        diffPks = diff(pklocs);

        artStarts = [pklocs(1); pklocs(find(diffPks > 3) + 1)];

        % median difference between signal onset and onset of stim artifact in
        % data
        sampDiff = median(round(artStarts - dataStarts)) - 1;
        % add this value to the start indices
        dataStarts = dataStarts + sampDiff;
    end
    
    %% Epoch data
    
    data_epoched = zeros(round((pre + post)*fsData) + 1, size(data, 2), 60);
    epoch_indices = [dataStarts - round(pre*fsData), dataStarts + round(post*fsData)];
    for trl = 1:length(burst_limits)
        if epoch_indices(trl, 1) < 1 || epoch_indices(trl, 2) > length(data)
            data_epoched(:, :, trl) = NaN;
        else
            data_epoched(:, :, trl) = data(epoch_indices(trl, 1):epoch_indices(trl, 2), :);
        end
    end
end

