function [data_epoched, epoch_indices, adj_by] = pullStimEpochs(data, burst_limits, fsData, fsSing, pre, post, varargin)
%PULLSTIMEPOCHS pulls epochs of identical size from provided data based on
%provided limits and trial stops

%   REQUIRED INPUTS:
%   data: data to be split into epochs (a time x channels array)
%   burst_limits: the start indices of each stimulation burst, 
%       as generated by getStimIndices(). Will ignore everything except the
%       first column
%   fsData: the sampling rate of data
%   fsSing: the sampling rate of the Sing TDT output that was used to
%       generate burst_limits
%   pre: the number of seconds to include in epoch prior to burst start
%   post: the number of seconds to include in epoch after burst start (this
%       will include the rest of the burst window to account for potential
%       differences in burst length

%   OPTIONAL INPUTS:
%   adjust: a boolean determining if you would like to adjust for
%       differences between TDT stimulation signal and stimulation artifact in
%       the data (defaults to false)
%   adj_by: a round double stating the number of samples you want to use to
%       adjust for differences between TDT stimulation signal and
%       stimulation artifact in the data, for instance if you would like
%       this value to be the same across all runs. If adjust is set to true
%       and no adj_by is specified, adj_by is calculated based on estimates
%       of the stim artifact in the data

%   OUTPUTS:
%   data_epoched: the data split into epochs (a time x channels x trials
%       array)
%   epoch_indices: the indices used to pull epochs from the given data,
%       accounting for sampling rate differences and adjustment for lag
%   adj_by: the number of samples used to adjust between TDT stimulation
%       signal and stimulation artifact in the data

    %% Parse inputs
    
    p = inputParser;
    
    % check for required inputs (as described above)
    validData = @(x) assert(isnumeric(x) && length(size(x)) == 2 && ...
        size(x, 1) > size(x, 2), ['data input must be a numeric array of'...
        ' size time x channels with more time points than channels']);
    addRequired(p, 'data', validData);

    addRequired(p, 'burst_limits', @isnumeric);
    
    validFs = @(x) assert(isnumeric(x) && isequal(size(x), [1, 1]), ...
        'fs inputs must be one numeric value each');
    addRequired(p, 'fsData', validFs);
    addRequired(p, 'fsSing', validFs);
    
    validVal = @(x) assert(isnumeric(x), ['pre/post inputs must be one'...
        ' numeric value each']);
    addRequired(p, 'pre', validVal);
    addRequired(p, 'post', validVal);
    
    % check for optional inputs and set to defaults if absent (as described above)
    validAdj = @(x) assert((x == 0 || x == 1) || (islogical(x)), ...
        'adjust must be equal to 0, 1, true, or false');
    addParameter(p, 'adjust', false, validAdj);
    
    validAdjBy = @(x) assert(isnan(x) || (isnumeric(x) && isequal(mod(x, 1), 0)) && ...
        isequal(size(x), [1, 1]), ['adj_by must be one '...
        'round numeric value or NaN']);
    addParameter(p,'adj_by', NaN, validAdjBy);
    
    % parse values
    p.parse(data, burst_limits, fsData, fsSing, pre, post, varargin{:});
    
    data = p.Results.data;
    burst_limits = p.Results.burst_limits;
    fsData = p.Results.fsData;
    fsSing = p.Results.fsSing;
    pre = p.Results.pre;
    post = p.Results.post;
    adjust = logical(p.Results.adjust);
    adj_by = p.Results.adj_by;
    

    %% Adjust for any differences in sampling rate between Sing and data
    
    fsRat = fsData/fsSing;
    dataStarts = round(fsRat*burst_limits(:, 1));
    
    %% Adjust for lag between stimulation onset signal and stimulation artifact
    
    if adjust && isnan(adj_by) % if adjustment is specified but no value is given
        
        % only uses data within -3*pre/+3*post of the start/end indices (to
        % avoid including outliers or other trials in stim indices)
        lims = [max(1, dataStarts(1) - round(3*pre*fsData)), ...
            min(dataStarts(end) + round(3*post*fsData), length(data))];
        
        % find the channel with the largest magnitude of differential and
        % use this channel's differential for indexing
        dataDiff = diff(data(lims(1):lims(2), :));
        [~,chanMax] = (max(max(dataDiff)));
        chanMax = chanMax(1);
        diffSig = dataDiff(:, chanMax);
        
        % any differential more than 8 standard deviations from the mean is
        % counted as a peak
        pklocs = find(abs(zscore(diffSig)) > 8);
        
        % find the first peak of a burst
        diffPks = diff(pklocs);
        if length(pklocs) == 1 % if only one peak is detected
            
            artStarts = pklocs + lims(1) - 1; % return to full time series indexing
            adj_by = min(abs(round(artStarts - dataStarts))) - 1; % find the closest Sing peak
            
        elseif ~isempty(diffPks)
            
            % finds start of artifacts based on the 85th percentile of
            % differences between identified peaks
            artStarts = [pklocs(1); pklocs(find(diffPks > quantile(diffPks, .85)) + 1)];
            artStarts = artStarts + lims(1) - 1; % return to full time series indexing

            % find the closest Sing peak to each data peak and take the
            % median of the differences between each of these closest peaks
            diffClosest = min(abs(round(artStarts' - dataStarts)));
            % if more than 10 ms between peak and artifact, assume the peak
            % identified is not related to a stimulus onset and remove
            diffClosest(diffClosest > fsData/100) = []; 
            adj_by = ceil(median(diffClosest)) - 1;
            
        else
            
            adj_by = 0;
            
        end
    elseif isnan(adj_by) % if no adjustment is specified
        
        adj_by = 0;
        
    end
    
    % adjust indices by computed or inputted value
    dataStarts = dataStarts + adj_by;
    
    %% Epoch data
    
    % start and end indices of each epoch
    epoch_indices = [dataStarts - round(pre*fsData), dataStarts + round(post*fsData)];
    % initialize matrix of time x channels x trials for data
    data_epoched = zeros(diff(epoch_indices(1, :)) + 1, size(data, 2), ...
        length(burst_limits));
    % fill data matrix by trial
    for trl = 1:length(burst_limits)
        % a catch for if the trial bounds are out of range for the data
        % (sets to NaN so index of trial is known from return values)
        if epoch_indices(trl, 1) < 1 || epoch_indices(trl, 2) > length(data)
            data_epoched(:, :, trl) = NaN;
        else
            data_epoched(:, :, trl) = data(epoch_indices(trl, 1):epoch_indices(trl, 2), :);
        end
    end
    
end