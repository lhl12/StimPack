function [stim_pulses, adj_by_all] = pullStimPulses(data, pulse_idx, fsData, fsSing, pre, post, varargin)
%PULLSTIMPULSES A wrapper for pullStimEpochs to pull individual pulses
%within a single burst

%   INPUTS:
%   data: data to be split into pulses (a time x channels array, NOT epoched)
%   pulse_idx: the indices of each individual pulse within a burst (a
%       trials x 1 cell array, each cell contains a pulses x 1 matrix,
%       indexing is *not* within the burst but over the full time series),
%       as generated by getStimIndices()
%   fsData: the sampling rate of data
%   fsSing: the sampling rate of the Sing TDT output that was used to
%       generate pulse_idx
%   pre: the number of seconds to include in epoch prior to pulse start
%   post: the number of seconds to include in epoch after pulse start (this
%       will include the rest of the burst window to account for potential
%       differences in burst length
%   adjust: a boolean determining if you would like to adjust for
%       differences between TDT stimulation signal and stimulation artifact in
%       the data (defaults to 0)

%   OUTPUTS:
%   stim_pulses: the data surrounding each individual pulse, a trials x 1
%       cell array, with each cell containing a time x channels x pulses
%       matrix
%   adj_by: the number of samples used to adjust between TDT stimulation
%       signal and stimulation artifact in the data for each trial, a
%       trials x 1 array

%   ASSUMPTIONS:
%   -sample differences will be relatively consistent across trials
%   -works best when there are multiple pulses in each trial (just use
%    pullStimEpochs with a smaller window if there is one pulse per trial
%    for efficiency and to avoid crashing)
%   -stim pre/post isolates each pulse relatively well

    %% Parse inputs
    
    p = inputParser;
    
    % check for required inputs (as described above)
    validData = @(x) assert(isnumeric(x) && length(size(x)) == 2 && ...
        size(x, 1) > size(x, 2), ['data input must be a numeric array of'...
        ' size time x channels with more time points than channels']);
    addRequired(p, 'data', validData);
    
    validLims = @(x) assert(isnumeric(x) && size(x, 2) == 1, ...
        'burst_limits must be a numeric array of size epochs x 1');
    addRequired(p, 'pulse_idx', validLims);
    
    validFs = @(x) assert(isnumeric(x) && isequal(size(x), [1, 1]), ...
        'fs inputs must be one numeric value each');
    addRequired(p, 'fsData', validFs);
    addRequired(p, 'fsSing', validFs);
    
    validVal = @(x) assert(isnumeric(x), ['pre/post inputs must be one'...
        ' numeric value each']);
    addRequired(p, 'pre', validVal);
    addRequired(p, 'post', validVal);
    
    % check for optional inputs and set to defaults if absent (as described above)
    validAdj = @(x) assert((x == 0 || x == 1) || (islogical(x)), ...
        'adjust must be equal to 0, 1, true, or false');
    addParameter(p, 'adjust', false, validAdj);
    
    validAdjBy = @(x) assert((isnumeric && isequal(mod(x, 1), 0)) && ...
        isequal(size(x), [1, 1]), 'adj_by must be one round numeric value');
    addParameter(p,'adj_by', NaN, validAdjBy);
    
    % parse values
    p.parse(data, pulse_idx, fsData, fsSing, pre, post, varargin{:});
    
    data = p.Results.data;
    pulse_idx = p.Results.pulse_idx;
    fsData = p.Results.fsData;
    fsSing = p.Results.fsSing;
    pre = p.Results.pre;
    post = p.Results.post;
    adjust = logical(p.Results.adjust);
    adj_by = p.Results.adjust;
    
    %% Pull the time immediately surrounding each individual pulse for each trial
    
    % initialize cell array for data and adjustment values
    stim_pulses = cell(size(pulse_idx));
    adj_by_all = zeros(size(pulse_idx));
    
    % loop through trials and call pullStimEpochs on the full time series
    % using the pulse indices as epoch start indices
    % NOTE: inefficient, but makes it easier to ID individual pulses in
    % noisy neural data
    for trl = 1:length(pulse_idx)
        
        disp(trl)
        pid = pulse_idx{trl};
        [stim_pulses{trl}, ~, adj_by_all(trl)] = pullStimEpochs(data, pid, fsData, ...
            fsSing, pre, post, 'adjust', adjust, 'adj_by', adj_by);
        
    end

end

